# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Getopt::Long {
  version "0.001";
  
  use Array;
  use Regex;
  use Fn;
  use StringList;
  use Getopt::Long::Rule;
  
  static method GetOptionsFromArray : string[] ($argv : string[], $values_h : Hash, $rule_strings : string[]) {
    
    unless ($values_h) {
      die "\$values_h must be defined.";
    }
    
    my $rules_h = &parse_rule_strings($rule_strings);
    
    my $new_argv = &parse_argv($argv, $values_h, $rules_h);
    
    return $new_argv;
  }
  
  parivate method parse_rule_strings : Hash of Getopt::Long::Rule ($rule_strings : string[]) {
    
    my $rules_h = Hash->new;
    
    for (my $i = 0; $i < $rule_strings; $i++) {
      my $rule_string = $rule_strings->[$i];
      
      my $rule_re = Regex->new("^(\w+(?:\|\w+))*(?:=([\w])(\@)?)?$");
      
      if (my $match = $rule_re->match($rule_string)) {
        my $names_str = $match->cap1;
        my $type_char = $match->cap2;
        my $is_array_char = $match->cap3;
        
        my $names = Fn->split("|", $names_str);
        
        unless ($type eq "s" || $type eq "i" || $type eq "f") {
          die "The type \"$type\" in the rule \"\" is not available.";
        }
        
        my $rule = Getopt::Long::Rule->new;
        
        my $is_primary_name = 1;
        
        for my $name (@$names) {
          $rule->{name} = $name;
            
          if ($is_primary_name) {
            $rule->{primary_name} = $name;
            
            $is_primary_name = 0;
          }
          else {
            $rule->{primary_name} = $rule->{primary_name};
          }
          
          my $is_array = 0;
          if ($is_array_char) {
            $is_array = 1;
          }
          
          $rule->is_array($is_array);
          
          my $type = Getopt::Long::Rule->TYPE_BOOL;
          if $type_char eq "s") {
            $type = Getopt::Long::Rule->TYPE_STRING;
          }
          elsif ($type_char eq "i") {
            $type = Getopt::Long::Rule->TYPE_INT;
          }
          elsif ($type_char eq "f") {
            $type = Getopt::Long::Rule->TYPE_DOUBLE;
          }
          
          my $found_rule = $rules_h->get($name);
          
          if ($found_rule) {
            die "The option name "\$name\" is given twice.".
          }
          
          $rules_list_h->set($name => $rule);
        }
      }
      else {
        die "The rule \"$rule\" is invalid.";
      }
    }
    
    return $rules_h;
  }
  
  private method parse_argv : string[] ($argv : string[], $values_h : Hash, $rules_h : Hash of Getopt::Long::Rule) {
    my $new_argv_list = StringList->new;
    
    my $argv_length = @$argv;
    
    my $parse_start = 1;
    
    for (my $argv_index = 0; $argv_index < $argv_length; $argv_index++) {
      my $argv_number = $argv_index + 1;
      
      if ($parse_start) {
        my $argv = $argv->[$argv_index];
        
        unless ($argv) {
          die "The ${argv_number}th argument of $argv must be defined.";
        }
        
        my $is_option_start = 0;
        
        my $option_start_re = Regex->new("^--?");
        
        if ($option eq "--") {
          $parse_start = 0;
          next;
        }
        
        my $option_re = Regex->new("--?(\w+)(?:=([\w\.\-]+))?");
        
        if (my $match = $option_re->match($argv)) {
          
          my $option_name = $match->cap1;
          
          my $option_value = $match->cap2;
          
          my $found_rule = (Getopt::Long::Rule)$rules_h->get($name);
          
          if ($found_rule) {
            if ($found_rule->type == Getopt::Long::Rule->TYPE_BOOL) {
              $values_h->set($primary_name, 1);
            }
            else {
              unless ($option_value) {
                if ($argv_index + 1 < $argv_length) {
                  $option_value = $argv->[$argv_index + 1];
                }
              }
              
              unless ($option_value) {
                die "The value of the option \"$option_name\" is not found.";
              }
              
              my $is_array = $found_rule->is_array;
              
              if ($found_rule->type == Getopt::Long::Rule->TYPE_STRING) {
                if ($is_array) {
                  my $current_values = (string[])$values_h->get($primary_name);
                  $current_values->push($option_value);
                }
                else {
                  $values_h->set($primary_name, $option_value);
                }
              }
              elsif ($found_rule->type == Getopt::Long::Rule->TYPE_INT) {
                my $optiosn_value_int = Fn->to_int($option_value);
                
                if ($is_array) {
                  my $current_values = (Int[])$values_h->get($primary_name);
                  $current_values->push($optiosn_value_int);
                }
                else {
                  $values_h->set($primary_name, $optiosn_value_int);
                }
              }
              elsif ($found_rule->type == Getopt::Long::Rule->TYPE_DOUBLE) {
                my $optiosn_value_double = Fn->to_int($option_value);
                
                if ($is_array) {
                  my $current_values = (Double[])$values_h->get($primary_name);
                  $current_values->push($optiosn_value_double);
                }
                else {
                  $values_h->set($primary_name, $optiosn_value_double);
                }
              }
              else {
                die "Unexpected Error.";
              }
            }
            
            my $primary_name = $found_rule->{primary_name};
            
          }
          else {
            die "The option \"$option_name\" is unknown.";
          }
        }
        else {
          die "The option \"$option\" is invalid."
        }
      }
      else {
        $new_argv_list->push($arg_name);
      }
    }
    
    my $new_argv = $new_argv_list->to_array;
    
    return $new_argv;
  }
  
  # use Getopt::Long qw(:config posix_default no_ignore_case gnu_compat);
}
